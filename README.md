# monitor-b
# monitor-b


# 🎛️ M32 USB 오디오 송출 시스템 — 최종 요구사항 스펙

---

## 📋 개요
Midas M32의 USB 멀티채널 오디오를 캡처해 Wi-Fi를 통해 클라이언트(안드로이드 + iOS)로 저지연 송출.  
클라이언트는 각 채널을 로컬에서 믹싱하며, 개인 설정을 저장하고 최신 패킷을 재생한다.

---

## 🎯 시스템 구성

### 🔷 서버
- 리눅스 서버 (Rust 백엔드 + FastAPI 웹 UI)
- M32 USB 연결 (32채널 오디오 캡처)
- UDP/RTP로 32채널 송출
- 설정은 JSON/YAML 파일로 관리
- 웹 UI에서 채널 이름, 오디오 포맷 등 설정 가능 (비밀번호 보호)
- 에러 로깅
- 네트워크 품질 모니터링 (손실률/지터/지연)

### 🔷 클라이언트
- 안드로이드 + iOS 앱
- UDP/RTP로 32채널 수신
- 로컬에서 믹싱 및 재생
- 개인 설정은 로컬에 저장
- 최신 패킷만 재생 (지연 최소화)
- 서버의 샘플레이트/코덱 변경 시 자동 재연결

### 🔷 네트워크
- 전용 5GHz AP
- 유니캐스트 UDP
- 클라이언트 최대 20명
- NTP 동기화

---

## 📡 클라이언트 ↔ 서버 연결

### 오디오 데이터
| 특성 | 내용 |
|------|------|
| 프로토콜 | UDP + RTP |
| 방향 | 서버 → 클라이언트 |
| 포트 | 고정 UDP 포트 (예: 5004) |
| 데이터 | 32채널 멀티채널 오디오 |

### 메타데이터
| 특성 | 내용 |
|------|------|
| 프로토콜 | HTTP (REST API) |
| 방향 | 클라이언트 → 서버 |
| 포트 | HTTP 포트 (예: 8000) |
| 데이터 | 채널 이름/번호/속성, 서버 상태, 네트워크 품질 |

---

## 🛰️ 서버 탐색 방법

클라이언트가 서버의 IP를 알아내는 방법:
✅ **mDNS (우선)**  
✅ **QR 코드 (대안)**  
✅ **수동 입력 (마지막 수단)**

### mDNS
- 서버가 `m32-server.local` 로 mDNS 브로드캐스트
- 클라이언트가 네트워크에서 이름으로 탐색

### QR 코드
- 서버 웹 UI에서 QR 코드 표시 (`m32-server.local` 또는 현재 IP)
- 클라이언트가 카메라로 스캔해 설정

### 수동 입력
- 클라이언트가 서버 IP를 직접 입력
- 앱에서 저장해 사용

---

## 🚀 클라이언트 연결 흐름

1️⃣ 클라이언트가 mDNS로 `m32-server.local` 탐색  
2️⃣ 실패 시 QR 코드 스캔  
3️⃣ 그래도 실패하면 수동 입력  
4️⃣ REST로 메타데이터 요청 → UDP로 오디오 수신

---

## 🎛️ 클라이언트 채널별 설정

| 속성 | 타입 | 설명 |
|------|------|-------|
| `id` | int | M32 USB 채널 번호 (1~32) |
| `name` | string | 채널 이름 |
| `mute` | bool | 음소거 |
| `hidden` | bool | UI 숨김 |
| `order` | int | UI 표시 순서 |
| `volume` | float | 볼륨 (0.0~1.0 or dB) |
| `solo` | bool | 솔로 |
| `pan` | float | 좌/우 밸런스 (-1.0~+1.0) |
| `eq` | object | EQ (low/mid/high) |
| `limit` | object/bool | 리미터 (on/off + 설정) |

### `eq` 예시
```json
"eq": {
  "low": -3.0,
  "mid": 0.0,
  "high": +2.5
}

```

---

## 🎚️ 오디오 송출 메타데이터 (압축/샘플레이트)

- 서버는 오디오 RTP 송출 시 **압축 방식(compression)**, **샘플레이트(sample_rate)** 정보를 설정 파일(config.yaml)로 관리합니다.
- 예시 설정:
  ```yaml
  compression: "none"   # 또는 "opus", "aac" 등
  sample_rate: 48000     # 단위: Hz
  ```
- 클라이언트는 서버의 REST API(`/status` 또는 `/audio-meta` 등)로 해당 정보를 먼저 조회해야 합니다.
- 예시 응답:
  ```json
  {
    "status": "ok",
    "compression": "none",
    "sample_rate": 48000,
    "channels": 32
  }
  ```
- 클라이언트는 이 정보를 바탕으로 RTP 스트림을 올바르게 디코딩/재생해야 합니다.
- 서버의 샘플레이트와 클라이언트가 원하는 샘플레이트가 다를 경우, 서버에서 리샘플링을 적용할 수 있습니다.

---

## 🛰️ 오디오 RTP 송출 방식 (Unicast)

- 서버는 **클라이언트의 IP/포트로 직접 RTP(UDP) 패킷을 송출**합니다.
- 멀티캐스트가 아닌, 단일 클라이언트(혹은 여러 클라이언트 각각)에 unicast로 전송합니다.
- 목적지 IP/포트는 서버 실행 시 환경변수로 지정합니다.

### 환경변수 예시
- `RTP_DEST_IP` : RTP 패킷을 받을 클라이언트의 IP 주소 (예: `192.168.0.101`)
- `RTP_DEST_PORT` : RTP 포트 (예: `5004`)

### 실행 예시
```sh
RTP_DEST_IP=192.168.0.101 RTP_DEST_PORT=5004 cargo run --bin backend
```

- 여러 클라이언트에 송출하려면, 서버에서 각 클라이언트 IP/포트로 반복 송출하도록 확장할 수 있습니다.

---

## 🔄 클라이언트-서버 연동 시나리오

1. **클라이언트는 mDNS 또는 수동 입력으로 서버의 IP를 얻는다.**
2. **클라이언트가 서버 IP에 음원(오디오 스트림) 요청을 보낸다.**
   - (예: REST API로 `/request-audio` 등)
3. **서버는 요청한 클라이언트의 IP로 RTP(UDP) 오디오 스트림을 전송한다.**
4. **클라이언트는 서버에 heartbeat(주기적 신호)를 전송하여 스트림 전송을 유지한다.**
   - (예: REST API로 `/heartbeat` 등)
5. **서버는 클라이언트로부터 30초 동안 heartbeat가 오지 않으면 RTP 전송을 중단한다.**

- 이 구조로, 클라이언트가 네트워크를 이탈하거나 앱이 종료되어도 서버가 자동으로 송출을 중단할 수 있습니다.
- heartbeat 주기는 5~10초 등으로 조정 가능하며, 서버/클라이언트 모두 구현 필요
